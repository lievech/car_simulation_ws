[01m[K/home/lhn/hhh_ws/src/mpc_controller/src/mpc_controller.cpp:[m[K In member function â€˜[01m[Kvoid waypoint_follower::MPC_Controller::CalculatePolynomial(Eigen::VectorXd&, Eigen::VectorXd&)[m[Kâ€™:
[01m[K/home/lhn/hhh_ws/src/mpc_controller/src/mpc_controller.cpp:243:33:[m[K [01;35m[Kwarning: [m[Kformat â€˜[01m[K%d[m[Kâ€™ expects argument of type â€˜[01m[Kint[m[Kâ€™, but argument 6 has type â€˜[01m[KEigen::EigenBase<Eigen::Matrix<double, -1, 1> >::Index {aka long int}[m[Kâ€™ [-Wformat=]
    ,wayPtPolynomialCoeffs.size());
[01;32m[K                                 ^[m[K
[01m[K/home/lhn/hhh_ws/src/mpc_controller/src/mpc_controller.cpp:[m[K In member function â€˜[01m[Kvoid waypoint_follower::MPC_Controller::Solve(const VectorXd&)[m[Kâ€™:
[01m[K/home/lhn/hhh_ws/src/mpc_controller/src/mpc_controller.cpp:458:123:[m[K [01;35m[Kwarning: [m[Knarrowing conversion of â€˜[01m[Ki[m[Kâ€™ from â€˜[01m[Kint[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™ inside { } [-Wnarrowing]
         double tmp[3] = {solution.x[px_range_begin + i], polyeval(wayPtPolynomialCoeffs,solution.x[px_range_begin + i]), i};
[01;32m[K                                                                                                                           ^[m[K
[01m[K/home/lhn/hhh_ws/src/mpc_controller/src/mpc_controller.cpp:465:91:[m[K [01;35m[Kwarning: [m[Knarrowing conversion of â€˜[01m[Ki[m[Kâ€™ from â€˜[01m[Kint[m[Kâ€™ to â€˜[01m[Kdouble[m[Kâ€™ inside { } [-Wnarrowing]
         double tmp[3] = {solution.x[px_range_begin + i], solution.x[py_range_begin + i], i};
[01;32m[K                                                                                           ^[m[K
